
public class memo {
/*	CRUD에 맞춰 개발자들이 만들어놓은 코드들 가져다사용 =>컬렉션
 * 	배열의 단점은 한개의 자료형과 중간중간 빈 배열을 체크해야한다는것
 * 	그래서 컬렉션을 사용하겠다
 * 	
 *  List 특징 : 순서가 있고 중복데이터 허용 >> 배열과 같음
 * 	Set 특징(집합) : 순서가 없고(인덱스X) 중복데이터 불허 >> 
 * 	
 * C > Create
 * R >
 * U >
 * D >
 * 
 * List내부 메소드
 * 조회 get(idx) 인덱스 데이터 조회
 * 추가 add(data) 리스트 마지막에 데이터추가
 * 변경 set(idx, data) 인덱스의 데이터 변경
 * 삭제 remove(idx) 인덱스의 데이터 삭제
 * 
 * 추가기능
 * add(idx, data) => 해당 인덱스에 데이터추가 (원래있던것은 한칸씩 뒤로밀림)
 * size() => 전체길이반환
 * isEmpty() = > 리스트가 비어있는지 확인(참,거짓)
 * clear() => 객체전체삭제
 * 
 * 
 * List를 구현받는 클래스 : ArrayList, LinkedList
 * ArrayList 특징 > 배열의 구조임
 * 인덱스번호를 통해 빠른조회 가능
 * 객체의 추가or삭제가 빈번한경우 속도가 느려진다(추가하면 그 인덱스부터 모든 데이터가 뒤로한칸씩밀림
 *										삭제하면 그 인덱스부터 끝까지 모든 데이터가 앞으로한칸씩밀림)
 * 즉, null배열은 존재하지않음
 * 
 * {A, B, C, D} 같은 구조임
 * 
 * 
 * LinkedList 특징 : 체인구조
 * 객체의 추가, 삭제가 비번해도 체인연결만 조절하면되므로 속도가 빠름
 * 인덱스가 있지만 해당위치를 찾기위해 처음부터 찾아가야하므로 조회가 느리다.
 * 
 * {A}-{B}-{C}-{D} 같은 구조
 * 
 * 
 * Set
 * add()
 * remove()
 * iterator();
 * 
 * 
 * HashSet 특징 : 객체가 가진 hashCode메소드와 equals 메소드를 통해 중복을 방지
 * 
 * 
 * treeSet 특징 : 이진트리를 기반으로 한 구조를 가진다.
 * 				객체가 크기순으로 정렬됨
 * 				크기 비교를위해 comparable인터페이스 / comparator인터페이스 사용
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * */
}
